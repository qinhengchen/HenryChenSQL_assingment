/*
1.In SQL Server, assuming you can find the result by using both joins and subqueries, which one would you prefer to use and why?

join will be prefered because sql server has optimizer for join operator

2.What is CTE and when to use it?

A Common Table Expression (CTE) is the result set of a query which exists temporarily and for use only within the context of a larger query. 
Much like a derived table, the result of a CTE is not stored and exists only for the duration of the query.

3.What are Table Variables? What is their scope and where are they created in SQL Server?

The table variable is a special type of the local variable that helps to store data temporarily, similar to the temp table in SQL Server. In fact, the table variable provides all the properties of the local variable, 
but the local variables have some limitations, unlike temp or regular tables.

4.What is the difference between DELETE and TRUNCATE? Which one will have better performance and why?

Delete command is useful to delete all or specific rows from a table specified using a Where clause
The truncate command removes all rows of a table. We cannot use a Where clause in this.
Delete command is slower than the Truncate command.

5.What is Identity column? How does DELETE and TRUNCATE affect it?

An identity column is a column (also known as a field) in a database table that is made up of values generated by the database. 
uncate reseeds identity values, whereas delete doesn't. 

6.What is difference between “delete from table_name” and “truncate table table_name”?
TRUNCATE always removes all the rows from a table, leaving the table empty and the table structure intact
whereas DELETE may remove conditionally if the where clause is used.

*/

-- 1.List all cities that have both Employees and Customers.
select * from Employees
select * from Customers


SELECT DISTINCT  c.City
FROM Customers c
WHERE EXISTS (SELECT 1 FROM Employees e WHERE e.city = c.city)
UNION 
SELECT DISTINCT  e.City
FROM Employees e
WHERE EXISTS (SELECT 1 FROM Customers c WHERE c.city = e.city);

select distinct c.city 
from Employees e
inner join Customers c
on e.city = c.city


--2.List all cities that have Customers but no Employee.
--a.Use sub-query
--b.Do not use sub-query

select distinct city 
from Customers
except
select distinct c.city 
from Employees e
inner join Customers c
on e.city = c.city

select distinct city 
from customers
where city not in
(select distinct city 
from Employees)

--3.List all products and their total order quantities throughout all orders.
select p.ProductName, sum(Quantity)
from [Order Details] as od
inner join Products as p 
on od.ProductID = p.ProductID
GROUP BY p.ProductName

--4.List all Customer Cities and total products ordered by that city.



select o.ShipCity, sum(Quantity)
from [Order Details] as od
inner join Products as p 
on od.ProductID = p.ProductID
inner join Orders as o
on o.OrderID = od.OrderID
inner join Customers as c
on c.CustomerID = o.CustomerID
GROUP BY o.ShipCity

--5.List all Customer Cities that have at least two customers.
--a.Use union
--b.Use sub-query and no union

select city, count(CustomerID) as cnt
from Customers
group by city
having count(CustomerID)>=2

--6.List all Customer Cities that have ordered at least two different kinds of products.
select o.shipcity, count(distinct p.ProductID)
from [order details] as od
inner join Orders as o
on  od. OrderID =  o.OrderID
inner join Products as p
on od.ProductID = p.ProductID
group by o.ShipCity
having count(distinct p.ProductID) >=2

--7.List all Customers who have ordered products, but have the ‘ship city’ on the order different from their own customer cities.

select distinct( c.CustomerID),c.City,o.ShipCity
from [Order Details] as od
inner join Products as p 
on od.ProductID = p.ProductID
inner join Orders as o
on o.OrderID = od.OrderID
inner join Customers as c
on c.CustomerID = o.CustomerID
where c.City<>o.ShipCity



--8.List 5 most popular products, their average price, and the customer city that ordered most quantity of it.

with 
c as (select top 5 p.ProductID,sum(Quantity) as quan
from [Order Details] as od
inner join Products as p 
on od.ProductID = p.ProductID
inner join Orders as o
on o.OrderID = od.OrderID
inner join Customers as c
on c.CustomerID = o.CustomerID
group by p.ProductID),

a as
(select p.ProductID,c.city, sum(od.Quantity) as total
from [Order Details] as od
inner join Products as p 
on od.ProductID = p.ProductID
inner join Orders as o
on o.OrderID = od.OrderID
inner join Customers as c
on c.CustomerID = o.CustomerID
group by c.City,p.ProductID)
,
d AS( 
SELECT * FROM(
select  *,RANK() OVER(PARTITION BY a.productID ORDER BY TOTAL DESC ) AS RNK
from a) B
WHERE RNK =1
 )
 select c.ProductID,d.City,c.quan
 from c
 inner join d
 on c.ProductID = d.ProductID

 --9.List all cities that have never ordered something but we have employees there.

 select distinct e.City
 from Employees as e
 where city not in(
 select distinct ShipCity
 from orders )

 --10.List one city, if exists, that is the city from where the employee sold most orders (not the product quantity) is, 
 --and also the city of most total quantity of products ordered from. (tip: join  sub-query)

 with a as
  (Select EmployeeID, count(OrderID)as cnt
 from orders
 group by EmployeeID
 )
 select e.City
 from Employees as e
 inner join(
 select EmployeeID 
 from a
 where cnt = (
 select  max(cnt)
 from a))b
 on b.EmployeeID = e.EmployeeID
 
 -- 11 How do you remove the duplicates record of a table?
 --We can use Common Table Expressions commonly known as CTE to remove duplicate rows in SQL Server. 

--We use a SQL ROW_NUMBER function, and it adds a unique sequential row number for the row.

-- 12 Sample table to be used for solutions below- Employee (empid integer, mgrid integer, deptid integer, salary money) Dept (deptid integer, deptname varchar(20))
--  Find employees who do not manage anybody.
select *
from employee e1 
inner join employee as e2
on e1.empid != e2.mgrid

--13. Find departments that have maximum number of employees. 
--(solution should consider scenario having more than 1 departments that have maximum number of employees). 
--Result should only have - deptname, count of employees sorted by deptname.

select *, DENSE_RANK() OVER(ORDER BY cnt desc) RNK
from(
select deptNAME, count(e.empid) as cnt
from employee as e
inner join dept as d
on d.depid =  e.depid
group by deptname
)a
where RNK = 1

--14 Find top 3 employees (salary based) in every department. 
--Result should have deptname, empid, salary sorted by deptname and then employee with high to low salary.
SELECT * FROM
(SELECT D.deptname, E.empid, E.salary, RANK() OVER(PARTITION BY D.DEPTNAME ORDER BY E.SALARY DESC ) AS RNK
FROM  employee as e
inner join dept as d
on d.depid =  e.depid) A
WHERE A.RNK <= 3